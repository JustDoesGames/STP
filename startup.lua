update=true;console=false;local c={"Removed logo for simplisity","Console on boot off by default","Fully reworked update system. (now goes through github & pastebin)","Updating is now 2x faster and now uses the 'http' api instead of shell","Label will no longer show 'Booting STP...'","Turtle is not longer required to be fueled to start in menu","Added patch notes","I am fully aware of current issues and in the process of fixing them."}local d,e=term.getSize()d,e=39,13;clr,cp,sb,st=term.clear,term.setCursorPos,term.setBackgroundColor,term.setTextColor;local function f()st(colors.gray)for g=1,d do write(string.char(127))end;st(colors.white)end;local function h()clr()cp(1,1)f()cp(1,e)f()cp(1,2)end;h()cp(d/2-string.len("STP")/2,2)print("STP")if fs.exists("/disk")and not fs.exists("/disk/startup.lua")and shell.getRunningProgram()~="/disk/startup.lua"then print("Type 'install' to install disk installer to '/disk/startup.lua'")write(": ")if string.lower(read())=="install"then if fs.exists("/disk")then if fs.exists("/disk/startup.lua")then fs.delete("/disk/startup.lua")end;fs.copy(shell.getRunningProgram(),"/disk/startup.lua")print("Installed to 'disk/startup.lua'. Rebooting...")sleep(1)os.reboot()end end end;local i=function(j)if console then print("[STP] "..j)sleep(.02)end end;local k=function(l)return os.setComputerLabel(tostring(l))end;local m=os.getComputerLabel()local n,o="Idle","e"if not http then i("Http is disabled. Skipping Update...")sleep(1)elseif not update then i("Updates disabled. Skipping...")sleep(1)else write("[STP] Checking for updates")local e=http.get("https://raw.githubusercontent.com/JustDoesGames/STP/main/startup.lua")local update=false;if e then update=e.readAll()e.close()end;textutils.slowPrint("...")if update then local j=fs.open(shell.getRunningProgram(),"r")local p=j.readAll()j.close()if update~=p then i("Update Found!")i("Update Process (0/2)")local q=fs.open(shell.getRunningProgram(),"w")q.write(update)q.close()i("Update Process (1/2)")if fs.exists("/disk/startup.lua")then print("Update disk? ('disk/startup.lua')")print("y - YES")print("n - NO")while true do _,a=os.pullEvent("key")if a==keys.y then if fs.exists("/disk/startup.lua")then fs.delete("/disk/startup.lua")end;fs.copy(shell.getRunningProgram(),"/disk/startup.lua")i("Disk updated.")break elseif a==keys.n then break end end end;i("Update Process (2/2)")i("Update Complete. Rebooting...")sleep(1)os.reboot()else i("You are Up-To-Date.")end else i("Failed to obtain update. Skipping Update...")end end;i("Cleaning up files...")if fs.exists("STP_tmp.lua")then fs.delete("STP_tmp.lua")end;if not turtle then k(m)clr()cp(1,1)i("Unit is not a t.")return end;local j=turtle;local r=j.getFuelLevel;local s,t=0,0;if not fs.exists("/startup.lua")and j then print("Install Simple t Program (STP)?")print("Type 'install' to install.")write(": ")if string.lower(read())=="install"then print("Installing...")if fs.exists("/startup.lua")then fs.delete("/startup.lua")end;fs.copy(shell.getRunningProgram(),"/startup.lua")print("Installed to 'startup.lua'. Rebooting...")sleep(1)os.reboot()end end;if shell.getRunningProgram()=="disk/startup.lua"then clr()cp(1,1)i("t plugged in. Unplug to use.")return end;i("Loading Functions...")local u={"c","8"}local function v()j.select(1)if r()==0 then j.refuel(1)if r()==0 then local w=1;i("Need Fuel to proceed...")while r()==0 do k("ยง"..u[w].."REFUEL")w=w+1;if w>#u then w=1 end;j.refuel(1)sleep(.5)end end end end;local function x(y,z)n,o=y or n,z or o;k("ยงf"..math.min(r(),9999).." | ยง"..o..n)end;local function A()h()print("Fuel: "..math.min(r(),9999).."  ")print("Distance: "..t.."  ")print("Blocks Broken: "..s.."  ")x()end;local function B()while j.dig()do j.dig()s=s+1;sleep(.25)end end;local function C()while j.digUp()do j.digUp()s=s+1;sleep(.25)end end;local function D()while j.digDown()do j.digDown()s=s+1;sleep(.25)end end;local function E()v()while not j.up()do j.digUp()sleep(.25)end end;local function F()v()while not j.down()do j.digDown()sleep(.25)end end;local function G()v()while not j.forward()do j.dig()sleep(.25)end;t=t+1 end;turnRight,turnLeft=j.turnRight,j.turnLeft;local function H(I)local J=nil;local function K(L)return math.ceil(J*I/L)end;clr()cp(1,1)f()cp(1,e)f()cp(1,2)write("Distance: ")J=tonumber(read())if J==nil or J<1 then i("Invalid input.")sleep(1)return false end;f()print("Current Fuel Level: "..r())print("Estimated Fuel Usage: "..J*I)f()print("(80) Coal/Charcoal - "..K(80))print("(120) Blaze Rods - "..K(120))print("(800) Coal/Charcoal Blocks - "..K(800))f()i("Press 'enter' to confirm...")_,b=os.pullEvent("key")if b~=keys.enter then return false end;return J end;local function M()clr()cp(1,1)print("Press 'enter' to continue")print("Patch Notes: ")for g=1,#c do sleep(.1)os.pullEvent("key")print(c[g])end;f()print("press any key to exit.")sleep(.5)os.pullEvent("key")end;local function N(J)if not J then return false end;A()i("Tunneling for "..J.." blocks...")x(J-1,"a")for g=1,J do j.turnLeft()A()B()E()A()B()j.turnRight()j.turnRight()A()B()A()F()A()B()j.turnLeft()if g~=J then while j.detect()do A()j.dig()sleep(.5)end;G()x(J-g-1,"a")end end;x("Idle","e")end;local function O()local dis=H(3)if dis then N(dis)turnRight()turnRight()for g=1,dis-1 do G()end;turnRight()turnRight()end end;local function P()local dis=H(6)if dis then N(dis)sleep(.5)j.turnLeft()j.turnLeft()E()E()N(dis)sleep(.5)j.turnLeft()j.turnLeft()F()F()end end;local function Q()local dis=H(2)if dis then for g=1,dis do A()G()x(dis-g,"a")C()if math.floor(g/5)==math.ceil(g/5)then j.turnRight()B()j.turnLeft()j.turnLeft()B()j.turnRight()end end;E()j.turnRight()B()j.turnLeft()j.turnLeft()B()F()j.turnLeft()for g=1,dis do A()x(dis-g,"a")G()end;j.turnLeft()j.turnLeft()x("Idle","e")end end;local function R()local dis=H(2)if dis then for g=1,dis do A()G()x(dis-g,"a")C()D()if math.floor(g/5)==math.ceil(g/5)then j.turnRight()B()j.turnLeft()j.turnLeft()B()j.turnRight()end end;j.turnRight()B()j.turnLeft()j.turnLeft()B()j.turnRight()F()j.turnRight()B()j.turnLeft()j.turnLeft()B()E()j.turnLeft()for g=1,dis do A()x(dis-g,"a")G()end;j.turnLeft()j.turnLeft()end end;local function S()local dis=H(0)if dis then for g=1,dis do A()G()x(dis-g,"a")C()D()if math.floor(g/5)==math.ceil(g/5)then j.turnRight()B()j.turnLeft()j.turnLeft()B()j.turnRight()end end;j.turnLeft()G()C()G()j.turnRight()for g=1,dis do A()G()x(dis-g,"a")C()D()if math.floor(g/5)==math.ceil(g/5)then j.turnRight()B()j.turnLeft()j.turnLeft()B()j.turnRight()end end;j.turnRight()j.turnRight()end end;local function T()print("BROKEN! PLEASE CONSULT OWNER.")sleep(3)end;local function U()local dis=H(2)if dis then for g=1,dis do B()A()G()x(dis-g,"a")j.turnLeft()B()j.turnRight()j.turnRight()B()j.turnLeft()end;j.turnRight()j.turnRight()for g=1,dis do G()end end end;local function V()local dis=H(5)if dis then N(dis)sleep(.5)j.turnLeft()E()E()B()j.turnLeft()j.turnLeft()B()j.turnRight()for g=1,dis-1 do B()A()G()x(dis-g,"a")j.turnLeft()B()j.turnRight()j.turnRight()B()j.turnLeft()end;sleep(.5)j.turnLeft()j.turnLeft()F()F()end end;local function W()h()print("w/s - Go forward / back")print("up/down - Go up / down")print("a/d - Turn left / right")print("e - Dig")print("r/f - Dig up / down")print("q - exit")while true do cp(1,e-1)write("Fuel Level: "..r())a,b=os.pullEvent("key")if b==keys.w then G()elseif b==keys.s then j.back()elseif b==keys.d then turnRight()elseif b==keys.a then turnLeft()elseif b==keys.up then E()elseif b==keys.down then F()elseif b==keys.e then B()elseif b==keys.r then C()elseif b==keys.f then D()elseif b==keys.q then break end end end;local function X()h()print("Infinite Mine")print("Press 'q' to exit.")local function Y()while true do B()sleep(.01)end end;local function Z()local b;while b~=keys.q do _,b=os.pullEvent("key")end end;parallel.waitForAny(Y,Z)end;local function a0()h()print("Infinite Mine - Dropping Down")print("Press 'q' to exit.")local function Y()while true do B()j.dropDown()sleep(.01)end end;local function Z()local b;while b~=keys.q do _,b=os.pullEvent("key")end end;parallel.waitForAny(Y,Z)end;local function a1()h()print("Infinite Rotate Mine")print("Press 'q' to exit.")local function Y()while true do B()sleep(.01)turnRight()end end;local function Z()local b;while b~=keys.q do _,b=os.pullEvent("key")end end;parallel.waitForAny(Y,Z)end;local function a2()h()print("Infinite Rotate Mine - Dropping Down")print("Press 'q' to exit.")local function Y()while true do B()j.dropDown()sleep(.01)turnRight()end end;local function Z()local b;while b~=keys.q do _,b=os.pullEvent("key")end end;parallel.waitForAny(Y,Z)end;local function a3()h()print("Infinite Attack")print("Press 'q' to exit.")local function Y()while true do j.attack()sleep(.01)end end;local function Z()local b;while b~=keys.q do _,b=os.pullEvent("key")end end;parallel.waitForAny(Y,Z)end;local function a4()h()print("Infinite Attack - Dropping Down")print("Press 'q' to exit.")local function Y()while true do j.attack()j.dropDown()sleep(.01)end end;local function Z()local b;while b~=keys.q do _,b=os.pullEvent("key")end end;parallel.waitForAny(Y,Z)end;local function a5()h()print("Infinite Rotate Attack")print("Press 'q' to exit.")local function Y()while true do j.attack()sleep(.01)turnRight()end end;local function Z()local b;while b~=keys.q do _,b=os.pullEvent("key")end end;parallel.waitForAny(Y,Z)end;local function a6()h()print("Infinite Rotate Attack - Dropping Down")print("Press 'q' to exit.")local function Y()while true do j.attack()j.dropDown()sleep(.01)turnRight()end end;local function Z()local b;while b~=keys.q do _,b=os.pullEvent("key")end end;parallel.waitForAny(Y,Z)end;local function a7()local dis=H(4)if dis then for g=1,dis do G()E()C()end;turnRight()turnRight()for g=1,dis do G()F()end;turnRight()turnRight()end end;local function a8()local dis=H(8)if dis then for g=1,dis do G()turnRight()B()turnLeft()turnLeft()B()turnRight()for g=1,2 do E()turnRight()B()turnLeft()turnLeft()B()turnRight()end;F()end;turnRight()turnRight()for g=1,dis do G()F()end;turnRight()turnRight()end end;local function a9(aa)st(colors.gray)clr()cp(1,1)print("Running Command: "..aa)st(colors.white)shell.run(aa)print("Press any key to continue...")os.pullEvent("key")end;local ab,ac=true,1;local ad={}local ae={{"Tunnel",{{"3x2 Tunnel - Single",O},{"3x3 Tunnel - Single+",V},{"3x4 Tunnel - Double",P},{"3x1 Tunnel - Flat",U}}},{"Strip Mine",{{"1x2 Strip Mine",Q},{"1x3 Strip Mine",R}}},{"Ininite",{{"Inf. Mine",X},{"Inf. Mine - Drop Down",a0},{"Inf. Rotate Mine",a1},{"Inf. Rotate Mine - Drop Down",a2},{"Inf. Attack",a3},{"Inf. Attack - Drop Down",a4},{"Inf. Rotate Attack",a5},{"Inf. Rotate Attack - Drop Down",a6}}},{"Staircase",{{"Single Staircase - Up",a7},{"Triple Staircase - Up",a8}}},{"Turtle",{{"Unequip",{{"Left",function()a9("unequip left")end},{"Right",function()a9("unequip right")end}}},{"Equip",{{"Left",function()a9("equip 1 left")end},{"Right",function()a9("equip 1 right")end}}}}},{"Misc.",{{"Manual Control",W}}},{"Patch Notes",M},{"Exit"}}local function af(ag)local function ah()clr()cp(1,1)f()cp(1,e)f()cp(d/2-1,2)write("STP")sb(colors.black)end;ah()while true do s=0;ah()cp(1,9)for g=1,math.min(e-5,#ag)do if ag[g+ac-1]then if g+ac-1==ac then paintutils.drawLine(1,g+3,d,g+3,colors.gray)st(colors.lightGray)cp(1,4)write(ac)st(colors.white)cp(d/2-string.len(ag[g+ac-1][1])/2,g+3)write(ag[g+ac-1][1])sb(colors.black)else st(colors.gray)cp(d/2-string.len(ag[g+ac-1][1])/2,g+3)write(ag[g+ac-1][1])end end end;st(colors.white)_,b=os.pullEvent("key")if b==keys.w or b==keys.up then if ac==1 then ac=#ag else ac=ac-1 end elseif b==keys.s or b==keys.down then if ac==#ag then ac=1 else ac=ac+1 end elseif b==keys.enter or b==keys.e then break end end;st(colors.white)for g=1,2 do ah()paintutils.drawLine(1,4,d,4,colors.gray)cp(d/2-string.len(ag[ac][1])/2,4)write(ag[ac][1])sb(colors.black)sleep(.05)ah()sleep(.05)end;return ac end;local function ai()local ag=ae;while ab do if ag[#ag][1]~="Back"and#ad~=0 then ag[#ag+1]={"Back"}end;af(ag)if type(ag[ac][2])=="table"then ad[#ad+1]={menu=ag,sel=ac}ag=ag[ac][2]ac=1 elseif not ag[ac][2]then if#ad==0 then ab=false else ag,ac=ad[#ad].menu,ad[#ad].sel;ad[#ad]=nil end elseif type(ag[ac][2])=="function"then s,t=0,0;ag[ac][2](dis)x("Idle","e")end end end;i("Executing STP...")x("Idle","e")ai()clr()cp(1,1)print("STP Closed.")sleep(0.2)
